# hash表

如何解决散列冲突：   
1、开放寻址法：线性探测、二次探查、双重散列。当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。   
2、链地址法： 基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表  

装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降

如何设计散列函数？
1. 散列函数的设计不能太复杂，减少计算开销  
2. 散列函数生成的值要尽可能随机并且均匀分布  

装载因子过大了怎么办？  
当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。

好的hash表设计：   
1、支持快速的查询、插入、删除操作；   
2、内存占用合理，不能浪费过多的内存空间；   
3、性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。  
设计一个合适的散列函数；
定义装载因子阈值，并且设计动态扩容策略；
选择合适的散列冲突解决方法。